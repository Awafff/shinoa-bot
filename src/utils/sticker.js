const axios = require('axios');
const { randomBytes } = require('crypto');
const Image = require('node-webpmux').Image;
const config = require("@config")

// by hardianto
const setting = {
  sessionInfo: {
    WA_VERSION: '2.2106.5',
    PAGE_UA: 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
    WA_AUTOMATE_VERSION: '3.6.10 UPDATE AVAILABLE: 3.6.11',
    BROWSER_VERSION: 'HeadlessChrome/88.0.4324.190',
    OS: 'Windows Server 2016',
    START_TS: 1614310326309,
    NUM: '6247',
    LAUNCH_TIME_MS: 7934,
    PHONE_VERSION: '2.20.205.16',
  },
  config: {
    sessionId: 'session',
    headless: true,
    qrTimeout: 20,
    authTimeout: 0,
    cacheEnabled: false,
    useChrome: true,
    killProcessOnBrowserClose: true,
    throwErrorOnTosBlock: false,
    chromiumArgs: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--aggressive-cache-discard',
      '--disable-cache',
      '--disable-application-cache',
      '--disable-offline-load-stale-cache',
      '--disk-cache-size=0'
    ],
    executablePath: 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
    skipBrokenMethodsCheck: true,
    stickerServerEndpoint: true,
  },
};

/**
 * Sets the EXIF data for a webp sticker.
 * 
 * @param {Buffer} webpSticker - The webp sticker buffer.
 * @param {string} packname - The name of the sticker pack.
 * @param {string} author - The author of the sticker pack.
 * @param {Object} [extra={}] - Additional metadata for the sticker pack.
 * @returns {Promise<Buffer>} - The buffer of the webp sticker with EXIF data.
 */
exports.setExif = async (webpSticker, packname, author, extra = {}) => {
  return new Promise(async (resolve, reject) => {
    try {
      const img = new Image();
      const stickerPackId = randomBytes(16).toString('hex').slice(0, 8);
      const json = {
        'sticker-pack-id': stickerPackId,
        'sticker-pack-name': author,
        'sticker-pack-publisher': packname,
        'sticker-pack-publisher-id': packname,
        'sticker-pack-version': '1.0.0',
        'android-app-store-link': config.api.url,
        'ios-app-store-link': config.api.url,
        'sticker-pack-description': `This sticker is a sticker that has been generated by ${config.bot.name}`,
        emojis: ['❤', '😍', '😘', '💕', '😻', '💑', '👩‍❤‍👩', '👨‍❤‍👨', '💏', '👩‍❤‍💋‍👩', '👨‍❤‍💋‍👨', '🧡', '💛', '💚', '💙', '💜', '🖤', '💔', '❣', '💞', '💓', '💗', '💖', '💘', '💝', '💟', '♥', '💌', '💋', '👩‍❤️‍💋‍👩', '👨‍❤️‍💋‍👨', '👩‍❤️‍👨', '👩‍❤️‍👩', '👨‍❤️‍👨', '👩‍❤️‍💋‍👨', '👬', '👭', '👫', '🥰', '😚', '😙', '👄', '🌹', '😽', '❣️', '❤️', '😀', '😃', '😄', '😁', '😆', '😅', '😂', '🤣', '🙂', '😛', '😝', '😜', '🤪', '🤗', '😺', '😸', '😹', '☺', '😌', '😉', '🤗', '😊', '🎊', '🎉', '🎁', '🎈', '👯‍♂️', '👯', '👯‍♀️', '💃', '🕺', '🔥', '⭐️', '✨', '💫', '🎇', '🎆', '🍻', '🥂', '🍾', '🎂', '🍰', '☹', '😣', '😖', '😫', '😩', '😢', '😭', '😞', '😔', '😟', '😕', '😤', '😠', '😥', '😰', '😨', '😿', '😾', '😓', '🙍‍♂', '🙍‍♀', '💔', '🙁', '🥺', '🤕', '☔️', '⛈', '🌩', '🌧,😯', '😦', '😧', '😮', '😲', '🙀', '😱', '🤯', '😳', '❗', '❕', '🤬', '😡', '😠', '🙄', '👿', '😾', '😤', '💢', '👺', '🗯️', '😒', '🥵', '👋'],
        ...extra,
      };

      let exifAttr = Buffer.from([0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);
      let jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');
      let exif = Buffer.concat([exifAttr, jsonBuffer]);
      exif.writeUIntLE(jsonBuffer.length, 14, 4);
      
      await img.load(webpSticker);
      img.exif = exif;
      resolve(await img.save(null));
    } catch (error) {
      reject(error);
    }
  });
};

/**
 * Creates a sticker from an image or video file.
 * 
 * @param {Buffer | String} file - The input file buffer or path.
 * @param {Object} [data={author: '', pack: '', keepScale: true, removebg: 'HQ', circle: false}] - Configuration options for the sticker.
 * @returns {Promise<Buffer>} - The buffer of the created sticker.
 */
exports.makeSticker = async (file, data = { author: '', pack: '', keepScale: true, removebg: 'HQ', circle: false }) => {
  return new Promise(async (resolve, reject) => {
    try {
      const buffer = await conn.toBuffer(file);
      if (buffer.mime === 'image/webp') {
        resolve(await this.setExif(buffer.buffer, data.author, data.pack));
        return;
      }

      const config2 = {
        ...data,
        processOptions: {
          crop: !data.keepScale,
          fps: 10,
          startTime: '00:00:00.0',
          endTime: '00:00:7.0',
          loop: 0,
        },
      };

      const DEFAULT_URL = 'https://sticker-api.openwa.dev/';
      const Type = buffer.mime.includes('image') ? 'image' : 'file';
      const url = `${DEFAULT_URL}${Type === 'image' ? 'prepareWebp' : 'convertMp4BufferToWebpDataUrl'}`;

      const { data: responseData } = await axios.post(url, JSON.stringify({
        ...setting,
        stickerMetadata: config2,
        [Type]: `data:${buffer.mime};base64,${buffer.buffer.toString('base64')}`,
      }), {
        headers: {
          Accept: 'application/json, text/plain, */*',
          'Content-Type': 'application/json;charset=utf-8',
          'User-Agent': 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
        },
        maxBodyLength: Infinity,
        maxContentLength: Infinity,
      });

      if (Type === 'image') {
        resolve(await this.setExif(Buffer.from(responseData.webpBase64, 'base64'), data.author, data.pack));
      } else {
        const webpBase = responseData.replace(/^data:(.*?);base64,/, '').replace(/ /g, '+');
        const fileBuffer = Buffer.from(webpBase, 'base64');
        resolve(await this.setExif(fileBuffer, data.author, data.pack));
      }
    } catch (error) {
      reject(error);
    }
  });
};
